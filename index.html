<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.17-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>go bits</title>
  

  
  <link rel="stylesheet" href="http://golang.rakyll.org/css/poole.css">
  <link rel="stylesheet" href="http://golang.rakyll.org/css/syntax.css">
  <link rel="stylesheet" href="http://golang.rakyll.org/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="http://golang.rakyll.org/index.xml" rel="alternate" type="application/rss+xml" title="go bits" />
</head>

<body class=" layout-reverse">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://golang.rakyll.org/"><h1>go bits</h1></a>
      <p class="lead">
      Lesser knowns about Go programming language and its tools.
      <br/>
      by <a href="https://twitter.com/rakyll">Jaana Burcu Dogan</a>
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      <li><a href="/archive">Archive</a> </li>
      <li><a href="/about">About</a> </li>
      
    </ul>

    <p class="small">
      This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
    </p>
  </div>
</div>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83257159-1', 'auto');
  ga('send', 'pageview');

</script>


    <div class="content container">
<div class="posts">


  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/leakingctx/">
        Using contexts to avoid leaking goroutines
      </a>
    </h1>

    <span class="post-date">Tue, Oct 25, 2016</span>

    <p>The <a href="https://godoc.org/pkg/context">context</a> package makes it possible
to manage a chain of calls within the same call path with <code>WithCancel</code>,
<code>WithDeadline</code>, and <code>WithTimeout</code>.</p>

<p>In this article, we will examine how to use the context package to
avoid leaking goroutines.</p>

<p>Assume, you have a function that starts a goroutine internally. Once this
function is called, the caller may not be able to terminate the goroutine
started by the function.</p>

<pre><code class="language-go">// gen is a broken generator that will leak a goroutine.
func gen() &lt;-chan int {
	ch := make(chan int)
	go func() {
		var n int
		for {
			ch &lt;- n
			n++
		}
	}()
	return ch
}
</code></pre>

<p><code>gen</code> starts a goroutine with an infinite loop, but the caller of <code>gen</code> consumes
the values returned until n is equal to 5.</p>

<pre><code class="language-go">// The call site of gen doesn't have a 
for n := range gen() {
    fmt.Println(n)
    if n == 5 {
        break
    }
}
</code></pre>

<p>Once the caller is done with the generator (when it breaks the loop),
the goroutine started in <code>gen</code> will run forever executing the infinite loop.</p>

<p>We can avoid the problem by signaling the internal goroutine with a
stop channel but there is a better solution: cancellable contexts. In
order to be able to cancel the goroutine, the gen function will select
on a context&rsquo;s Done channel. And once the context is done, we
will return from the goroutine.</p>

<pre><code class="language-go">// gen is a generator that can be cancellable by cancelling the ctx.
func gen(ctx context.Context) &lt;-chan int {
	ch := make(chan int)
	go func() {
		var n int
		for {
			select {
			case &lt;-ctx.Done():
				return // avoid leaking of this goroutine when ctx is done.
			default:
				ch &lt;- n
				n++
			}
		}
	}()
	return ch
}
</code></pre>

<p>The caller now can signal the generator when it is done by cancelling the context.
The generator won&rsquo;t generate any more values and the internal goroutine will be
returned.</p>

<pre><code>ctx, cancel := context.WithCancel(context.Background())
defer cancel() // make sure all paths cancel the context to avoid context leak

for n := range gen(ctx) {
    fmt.Println(n)
    if n == 5 {
        cancel()
        break
    }
}

// ...
</code></pre>

<p>The full program is available as a <a href="https://gist.github.com/rakyll/1aa860377dab8fd445431bbb3204f600">gist</a>.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/codegen/">
        Debugging code generation in Go
      </a>
    </h1>

    <span class="post-date">Sat, Oct 15, 2016</span>

    

<p><em>Last week, I was at <a href="http://www.dotgo.eu/">dotGo</a>, participating one of the
finest Go conferences and catching up with gophers from the other side of the
Atlantic. I gave a very short lightning talk about inspection of code generation
with the tools alrady available in the toolchain. This post goes through the talk for
those who didn&rsquo;t have to priviledge to be at the conference. Slides are also
available at <a href="https://go-talks.appspot.com/github.com/rakyll/talks/gcinspect/talk.slide">go-talks</a>.</em></p>

<p>Through the article, we will use the following program:</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
    sum := 1 + 1
    fmt.Printf(&quot;sum: %v\n&quot;, sum)
}
</code></pre>

<h3 id="toolchain">Toolchain</h3>

<p>Go build is a command that encapsulates tons of things from the user.
But, it also provides more detailed information about what it does if you ask for it.
<code>-x</code> is a flag that makes go build output what is being invoked.
If you want to see what the components of the toolchain are,
which sequence they are invoked and which flags being used, use <code>-x</code>.</p>

<pre><code>$ go build -x
WORK=/var/folders/00/1b8h8000h01000cxqpysvccm005d21/T/go-build190726544
mkdir -p $WORK/hello/_obj/
mkdir -p $WORK/hello/_obj/exe/
cd /Users/jbd/src/hello
/Users/jbd/go/pkg/tool/darwin_amd64/compile -o $WORK/hello.a -trimpath $WORK -p main -complete -buildid d934a5702088e0fe5c931a55ff26bec87b80cbdc -D _/Users/jbd/src/hello -I $WORK -pack ./hello.go
cd .
/Users/jbd/go/pkg/tool/darwin_amd64/link -o $WORK/hello/_obj/exe/a.out -L $WORK -extld=clang -buildmode=exe -buildid=d934a5702088e0fe5c931a55ff26bec87b80cbdc $WORK/hello.a
mv $WORK/hello/_obj/exe/a.out hello
</code></pre>

<h3 id="intermediate-assembly">Intermediate assembly</h3>

<p>In Go, there is an intermediate assembly phase before generating the actual arch-specific assembly.
Compiler takes some Go files, generates the intermediate instructions and escalate it to the <code>obj</code> package to generate the machine code.
If you are curious about what compiler generates in this phase, <code>-S</code> makes the compiler dumps the output.</p>

<p>The intermediate assembly is generally good reference to understand the cost of a Go line.
Or it coulbe be a great reference if you want to replace, let&rsquo;s say, a Go function with more optimized assembly equivalent.</p>

<p>You are seeing the output for the main.main here.</p>

<pre><code>$ go build -gcflags=&quot;-S&quot;
# hello
&quot;&quot;.main t=1 size=179 args=0x0 locals=0x60
    0x0000 00000 (/Users/jbd/src/hello/hello.go:5)  TEXT    &quot;&quot;.main(SB), $96-0
    0x0000 00000 (/Users/jbd/src/hello/hello.go:5)  MOVQ    (TLS), CX
    0x0009 00009 (/Users/jbd/src/hello/hello.go:5)  CMPQ    SP, 16(CX)
    0x000d 00013 (/Users/jbd/src/hello/hello.go:5)  JLS 169
    0x0013 00019 (/Users/jbd/src/hello/hello.go:5)  SUBQ    $96, SP
    0x0017 00023 (/Users/jbd/src/hello/hello.go:5)  MOVQ    BP, 88(SP)
    0x001c 00028 (/Users/jbd/src/hello/hello.go:5)  LEAQ    88(SP), BP
    0x0021 00033 (/Users/jbd/src/hello/hello.go:5)  FUNCDATA    $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)
    0x0021 00033 (/Users/jbd/src/hello/hello.go:5)  FUNCDATA    $1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)
    0x0021 00033 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $2, &quot;&quot;.autotmp_1+64(SP)
    0x002a 00042 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $0, &quot;&quot;.autotmp_0+72(SP)
    0x0033 00051 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $0, &quot;&quot;.autotmp_0+80(SP)
    0x003c 00060 (/Users/jbd/src/hello/hello.go:7)  LEAQ    type.int(SB), AX
    0x0043 00067 (/Users/jbd/src/hello/hello.go:7)  MOVQ    AX, (SP)
    0x0047 00071 (/Users/jbd/src/hello/hello.go:7)  LEAQ    &quot;&quot;.autotmp_1+64(SP), AX
    0x004c 00076 (/Users/jbd/src/hello/hello.go:7)  MOVQ    AX, 8(SP)
    0x0051 00081 (/Users/jbd/src/hello/hello.go:7)  PCDATA  $0, $1
    0x0051 00081 (/Users/jbd/src/hello/hello.go:7)  CALL    runtime.convT2E(SB)
    0x0056 00086 (/Users/jbd/src/hello/hello.go:7)  MOVQ    16(SP), AX
    0x005b 00091 (/Users/jbd/src/hello/hello.go:7)  MOVQ    24(SP), CX
    0x0060 00096 (/Users/jbd/src/hello/hello.go:7)  MOVQ    AX, &quot;&quot;.autotmp_0+72(SP)
    0x0065 00101 (/Users/jbd/src/hello/hello.go:7)  MOVQ    CX, &quot;&quot;.autotmp_0+80(SP)
    0x006a 00106 (/Users/jbd/src/hello/hello.go:7)  LEAQ    go.string.&quot;sum: %v\n&quot;(SB), AX
    0x0071 00113 (/Users/jbd/src/hello/hello.go:7)  MOVQ    AX, (SP)
    0x0075 00117 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $8, 8(SP)
    0x007e 00126 (/Users/jbd/src/hello/hello.go:7)  LEAQ    &quot;&quot;.autotmp_0+72(SP), AX
    0x0083 00131 (/Users/jbd/src/hello/hello.go:7)  MOVQ    AX, 16(SP)
    0x0088 00136 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $1, 24(SP)
    0x0091 00145 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $1, 32(SP)
    0x009a 00154 (/Users/jbd/src/hello/hello.go:7)  PCDATA  $0, $1
    0x009a 00154 (/Users/jbd/src/hello/hello.go:7)  CALL    fmt.Printf(SB)
    0x009f 00159 (/Users/jbd/src/hello/hello.go:8)  MOVQ    88(SP), BP
    0x00a4 00164 (/Users/jbd/src/hello/hello.go:8)  ADDQ    $96, SP
    0x00a8 00168 (/Users/jbd/src/hello/hello.go:8)  RET
    0x00a9 00169 (/Users/jbd/src/hello/hello.go:8)  NOP
    0x00a9 00169 (/Users/jbd/src/hello/hello.go:5)  PCDATA  $0, $-1
    0x00a9 00169 (/Users/jbd/src/hello/hello.go:5)  CALL    runtime.morestack_noctxt(SB)
    0x00ae 00174 (/Users/jbd/src/hello/hello.go:5)  JMP 0
    ...
</code></pre>

<p>If you would like to learn more insights about the intermediate assembly and why
it is significant in Go, I highly recommend
<a href="https://www.youtube.com/watch?v=KINIAgRpkDA">Rob Pike&rsquo;s The Design of the Go Assembler</a>
from GopherCon this year.</p>

<h3 id="disassembler">Disassembler</h3>

<p>As I mentioned, <code>-S</code> is only for the intermediate assembly. The actual machine representation is available in the final artifact.
You can use a disassembler to examine what&rsquo;s inside.
Use <code>go tool objdump</code> with a binary or library. You probably also want to use <code>-s</code> to focus by symbol name.
In this example, I am dumping the main.main. This is the actual assembly generated for <code>darwin/amd64</code>.</p>

<pre><code>$ go tool objdump -s main.main hello
TEXT main.main(SB) /Users/jbd/src/hello/hello.go
    hello.go:5  0x2040  65488b0c25a0080000  GS MOVQ GS:0x8a0, CX
    hello.go:5  0x2049  483b6110            CMPQ 0x10(CX), SP
    hello.go:5  0x204d  0f8696000000        JBE 0x20e9
    hello.go:5  0x2053  4883ec60            SUBQ $0x60, SP
    hello.go:5  0x2057  48896c2458          MOVQ BP, 0x58(SP)
    hello.go:5  0x205c  488d6c2458          LEAQ 0x58(SP), BP
    hello.go:7  0x2061  48c744244002000000  MOVQ $0x2, 0x40(SP)
    hello.go:7  0x206a  48c744244800000000  MOVQ $0x0, 0x48(SP)
    hello.go:7  0x2073  48c744245000000000  MOVQ $0x0, 0x50(SP)
    hello.go:7  0x207c  488d053d4d0800      LEAQ 0x84d3d(IP), AX
    ...
</code></pre>

<h3 id="symbols">Symbols</h3>

<p>Sometimes, all you need is to check the symbols rather than understanding code or data sections.
Similar to general-purpose nm tool, Go distributes an nm which allows you to list the symbols in an artifact with annotations and size.
Pretty handy if you want to see what&rsquo;s in and being exported from a Go binary or library.</p>

<pre><code>$ go tool nm hello
...
f4760 B __cgo_init
f4768 B __cgo_notify_runtime_init_done
f4770 B __cgo_thread_start
4fb70 T __rt0_amd64_darwin
4e220 T _gosave
4fb90 T _main
ad1e0 R _masks
4fd00 T _nanotime
4e480 T _setg_gcc
ad2e0 R _shifts
624a0 T errors.(*errorString).Error
62400 T errors.New
52470 T fmt.(*buffer).WriteRune
...
</code></pre>

<h3 id="optimizations">Optimizations</h3>

<p>With the contribution of the new SSA backend, the team contributed a tool that visualizes all the SSA passes.
Set GOSSAFUNC env variable with a func name and run the go build command.
It will generate an ssa.html file which will provide all the steps, compiler has gone through to optimize your code.</p>

<pre><code>$ GOSSAFUNC=main go build &amp;&amp; open ssa.html
</code></pre>

<p>Here, there is a visualization of all the passes applied to the main function.</p>

<p><img src="/img/ssa.png" alt="SSA optimizations" /></p>

<p>Go compiler can also annotate the inlining and escape analysis.
If you pass <code>-m=2</code> flag to the compiler, it will output the optimizations or annotations related to these two.
Here we see the <code>net/context</code> package related inlining operations and escape analysis.</p>

<pre><code>$ go build -gcflags=&quot;-m&quot; golang.org/x/net/context
# golang.org/x/net/context
../golang.org/x/net/context/context.go:140: can inline Background as: func() Context { return background }
../golang.org/x/net/context/context.go:149: can inline TODO as: func() Context { return todo }
../golang.org/x/net/context/go17.go:32: cannot inline WithCancel: non-leaf function
../golang.org/x/net/context/go17.go:46: cannot inline WithDeadline: non-leaf function
../golang.org/x/net/context/go17.go:61: cannot inline WithTimeout: non-leaf function
../golang.org/x/net/context/go17.go:62: inlining call to time.Time.Add method(time.Time) func(time.Duration) time.Time { time.t·2.sec += int64(time.d·3 / time.Duration(1000000000)); var time.nsec·4 int32; time.nsec·4 = &lt;N&gt;; time.nsec·4 = time.t·2.nsec + int32(time.d·3 % time.Duration(1000000000)); if time.nsec·4 &gt;= int32(1000000000) { time.t·2.sec++; time.nsec·4 -= int32(1000000000) } else { if time.nsec·4 &lt; int32(0) { time.t·2.sec--; time.nsec·4 += int32(1000000000) } }; time.t·2.nsec = time.nsec·4; return time.t·2 }
../golang.org/x/net/context/go17.go:70: cannot inline WithValue: non-leaf function
../golang.org/x/net/context/context.go:141: background escapes to heap
../golang.org/x/net/context/context.go:141:     from ~r0 (return) at ../golang.org/x/net/context/context.go:140
../golang.org/x/net/context/context.go:150: todo escapes to heap
../golang.org/x/net/context/context.go:150:     from ~r0 (return) at ../golang.org/x/net/context/context.go:149
../golang.org/x/net/context/go17.go:33: parent escapes to heap
../golang.org/x/net/context/go17.go:33:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:33
../golang.org/x/net/context/go17.go:32: leaking param: parent
../golang.org/x/net/context/go17.go:32:     from parent (interface-converted) at ../golang.org/x/net/context/go17.go:33
../golang.org/x/net/context/go17.go:32:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:33
../golang.org/x/net/context/go17.go:47: parent escapes to heap
../golang.org/x/net/context/go17.go:47:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:47
../golang.org/x/net/context/go17.go:46: leaking param: parent
../golang.org/x/net/context/go17.go:46:     from parent (interface-converted) at ../golang.org/x/net/context/go17.go:47
../golang.org/x/net/context/go17.go:46:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:47
../golang.org/x/net/context/go17.go:46: leaking param: deadline
../golang.org/x/net/context/go17.go:46:     from deadline (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:46
../golang.org/x/net/context/go17.go:48: ctx escapes to heap
../golang.org/x/net/context/go17.go:48:     from ~r2 (return) at ../golang.org/x/net/context/go17.go:46
../golang.org/x/net/context/go17.go:61: leaking param: parent
../golang.org/x/net/context/go17.go:61:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:61
../golang.org/x/net/context/go17.go:71: parent escapes to heap
../golang.org/x/net/context/go17.go:71:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:71
../golang.org/x/net/context/go17.go:70: leaking param: parent
../golang.org/x/net/context/go17.go:70:     from parent (interface-converted) at ../golang.org/x/net/context/go17.go:71
../golang.org/x/net/context/go17.go:70:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:71
../golang.org/x/net/context/go17.go:70: leaking param: key
../golang.org/x/net/context/go17.go:70:     from key (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:70
../golang.org/x/net/context/go17.go:70: leaking param: val
../golang.org/x/net/context/go17.go:70:     from val (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:70
../golang.org/x/net/context/go17.go:71: context.WithValue(parent, key, val) escapes to heap
../golang.org/x/net/context/go17.go:71:     from ~r3 (return) at ../golang.org/x/net/context/go17.go:70
&lt;autogenerated&gt;:1: leaking param: .this
&lt;autogenerated&gt;:1:  from .this.Deadline() (receiver in indirect call) at &lt;autogenerated&gt;:1
&lt;autogenerated&gt;:2: leaking param: .this
&lt;autogenerated&gt;:2:  from .this.Done() (receiver in indirect call) at &lt;autogenerated&gt;:2
&lt;autogenerated&gt;:3: leaking param: .this
&lt;autogenerated&gt;:3:  from .this.Err() (receiver in indirect call) at &lt;autogenerated&gt;:3
&lt;autogenerated&gt;:4: leaking param: key
&lt;autogenerated&gt;:4:  from .this.Value(key) (parameter to indirect call) at &lt;autogenerated&gt;:4
&lt;autogenerated&gt;:4: leaking param: .this
&lt;autogenerated&gt;:4:  from .this.Value(key) (receiver in indirect call) at &lt;autogenerated&gt;:4
</code></pre>

<p>You can use <code>-m</code> to see a less verbose output without reasonings, but <a href="https://twitter.com/Dr2chase/status/788353223522455552">David Chase</a> says
even though <code>-m=2</code> is not perfect, it is often useful.</p>

<p>It is worth to mention that you often need to disable optimizations to have a simpler view of what&rsquo;s going on.
Because, optimazation can change the sequence of operations, add code, remove code or apply transformations to the code.
With optimizations, it gets harder to map a Go line to the optimized output or it gets harder to do perf testing where you end up chaging more than one thing at a time.
Disabling optimizations is possible with <code>-N</code>, and disabling inlining is possible with <code>-l</code>.</p>

<pre><code>$ go build -gcflags=&quot;-l -N&quot;
</code></pre>

<p>Once optimizations are disabled, you can debug without being affected by transformations or do perf
testing without being affected more than one change at a time.</p>

<h3 id="lexer">Lexer</h3>

<p>If you are working on the lexer, compiler provides a flag to debug
the lexer as the lexer is going through the source files.</p>

<pre><code>$ go build -gcflags=&quot;-x&quot;
# hello
lex: PACKAGE
lex: ident main
lex: implicit semi
lex: IMPORT
lex: string literal
lex: implicit semi
lex: FUNC
lex: ident main
./hello.go:5 lex: TOKEN '('
./hello.go:5 lex: TOKEN ')'
./hello.go:5 lex: TOKEN '{'
lex: ident sum
./hello.go:6 lex: TOKEN COLAS
lex: integer literal
./hello.go:6 lex: TOKEN '+'
lex: integer literal
lex: implicit semi
lex: ident fmt
./hello.go:7 lex: TOKEN '.'
lex: ident Printf
./hello.go:7 lex: TOKEN '('
lex: string literal
./hello.go:7 lex: TOKEN ','
lex: ident sum
./hello.go:7 lex: TOKEN ')'
lex: implicit semi
./hello.go:8 lex: TOKEN '}'
lex: implicit semi
</code></pre>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/human-first/">
        Keeping Go a human-first language
      </a>
    </h1>

    <span class="post-date">Tue, Oct 11, 2016</span>

    <p><em>Disclaimer: I forked my opinions on this one from a barely readable Twitter thread
and wanted to write it down how I feel about keeping the language internals away
from the users, especially from the newcomers. This is not a skill-level concern,
it is a core goal of Go to provide a high-level programming language that saves users from
excessive mental overhead. Note that these
are personal opinons and are not writen on the behalf of a group.</em></p>

<p>Go is a highly opiniated language when it comes to API design,
readability and human-first approach.
It is critical to understand these aspects and the history of the language
before deep diving into more.</p>

<p>Go is created at Google to make engineers more productive and do more without
mental overload. Go wishes that behavior is predictable from a human perspective,
rather than humans are being enforced to think like machines to be efficient and productive.
Go sets the same high bar for its runtime. Go wishes to be good enough
to be doing the right for the most of the time &ndash; anything else can be optimized.</p>

<p>It is highly critical for us to keep Go users having
high expectations that things will work out of the box, and escalating major problems
to the team where the promise is not matching the actual behavior. Go is far away from being
a perfect language. It is important not to be sold so quickly and participate in the future of the
language if you are already skilled to understand the internals and their pitfalls.</p>

<p>I encourage our users to <a href="https://golang.org/issues/new">report bugs</a> rather than creating
extensive documentation around how to hack the current limitiations for the short-term gain.
There is much space for improvement in Go and the team desperately needs actual feedback from
actual users to commit work in the right direction.
Go needs to understand its users rather than users having to understand
every aspect of the language. This is the only scalable
approach.</p>

<p>Maybe along the way, our core goal of creating a human-first language will
be challenged, but I believe Go has proven that a language can be high-level,
precise and performant at the same time. I see no reason we should give up on this
so quickly. I apologize on the behalf of everyone involved in Go for a long time
to forget that this specific language goal needs to keep being communicated better.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/go-tool-flags/">
        Go tooling essentials
      </a>
    </h1>

    <span class="post-date">Sun, Sep 25, 2016</span>

    

<p>New to the Go tools? Or do you want to expand your knowledge? This article is
about the flags for the Go tools everyone should know.</p>

<p><em>Disclaimer: This article might be slightly biased. This is a collection of
flags I personally use and flags people around me having trouble finding references for.
If you have more ideas, ping me on <a href="https://twitter.com/rakyll">Twitter</a>.</em></p>

<h3 id="go-build-x">$ go build -x</h3>

<p><code>-x</code> lists all the commands go build invokes.</p>

<p>If you are curious about the Go toolchain, or using a cross-C compiler and
wondering about flags passed to the external compiler, or suspicious about
a linker bug; use <code>-x</code> to see all the invocations.</p>

<pre><code>$ go build -x
WORK=/var/folders/00/1b8h8000h01000cxqpysvccm005d21/T/go-build600909754
mkdir -p $WORK/hello/perf/_obj/
mkdir -p $WORK/hello/perf/_obj/exe/
cd /Users/jbd/src/hello/perf
/Users/jbd/go/pkg/tool/darwin_amd64/compile -o $WORK/hello/perf.a -trimpath $WORK -p main -complete -buildid bbf8e880e7dd4114f42a7f57717f9ea5cc1dd18d -D _/Users/jbd/src/hello/perf -I $WORK -pack ./perf.go
cd .
/Users/jbd/go/pkg/tool/darwin_amd64/link -o $WORK/hello/perf/_obj/exe/a.out -L $WORK -extld=clang -buildmode=exe -buildid=bbf8e880e7dd4114f42a7f57717f9ea5cc1dd18d $WORK/hello/perf.a
mv $WORK/hello/perf/_obj/exe/a.out perf
</code></pre>

<h3 id="go-build-gcflags">$ go build -gcflags</h3>

<p>Used to pass flags to the Go compiler. <code>go tool compile -help</code> lists all
the flags that can be passed to the compiler.</p>

<p>For example, to disable compiler optimizations and inlining, you can use
the following the gcflags.</p>

<pre><code>$ go build -gcflags=&quot;-N -l&quot;
</code></pre>

<h3 id="go-test-v">$ go test -v</h3>

<p>It provides chatty output for the testing. It prints the test name,
its status (failed or passed), how much it took to run the test, any logs
from the test case, etc.</p>

<p>go test without the <code>-v</code> flag is highly quiet, I always use it with <code>-v</code> turned on.
Sample output:</p>

<pre><code>$ go test -v context
=== RUN   TestBackground
--- PASS: TestBackground (0.00s)
=== RUN   TestTODO
--- PASS: TestTODO (0.00s)
=== RUN   TestWithCancel
--- PASS: TestWithCancel (0.10s)
=== RUN   TestParentFinishesChild
--- PASS: TestParentFinishesChild (0.00s)
=== RUN   TestChildFinishesFirst
--- PASS: TestChildFinishesFirst (0.00s)
=== RUN   TestDeadline
--- PASS: TestDeadline (0.16s)
=== RUN   TestTimeout
--- PASS: TestTimeout (0.16s)
=== RUN   TestCanceledTimeout
--- PASS: TestCanceledTimeout (0.10s)
...
PASS
ok  	context	2.426s
</code></pre>

<h3 id="go-test-race">$ go test -race</h3>

<p><a href="https://blog.golang.org/race-detector">Go&rsquo;s race detector</a> is available
from the Go tools via <code>-race</code>. go test also supports this flag and reports races.
Use this flag during development to detect the races.</p>

<h3 id="go-test-run">$ go test -run</h3>

<p>You can filter tests to run by regex and the <code>-run</code> flag. The following command
will only <a href="https://blog.golang.org/examples">test examples</a>.</p>

<pre><code>$ go test -run=Example
</code></pre>

<h3 id="go-test-coverprofile">$ go test -coverprofile</h3>

<p>You can output a cover profile as you are testing a package, then use go tool to
visualize them on a browser.</p>

<pre><code>$ go test -coverprofile=c.out &amp;&amp; go tool cover -html=c.out
</code></pre>

<p>The command above will create a coverage profile and open the results page in
the browser. The visualized results will look like the page below:</p>

<p><img src="/img/context-coverage.png" alt="context coverage" /></p>

<h3 id="go-test-exec">$ go test -exec</h3>

<p>It is a lesser known feature in Go that you can intercept the tools with another
program by using the <code>-exec</code> flag. This flag allows you to delegate some work to an
external program from the Go tool.</p>

<p>A commonly required scenario for this flag is when you need more than just executing
the tests on the host machine. The Android builder for Go, uses <code>-exec</code> to push the
test binaries to an Android device by using <code>adb</code> and collects the results.
<a href="https://github.com/golang/go/blob/master/misc/android/go_android_exec.go">Android exec program</a>
can be used as a reference.</p>

<h3 id="go-get-u">$ go get -u</h3>

<p>If you run go-get for a package that is already in your GOPATH, go-get
is not going to update the package to its latest version.
<code>-u</code> forces the tool to sync with the latest version of the repo.</p>

<p>If you are a library author, you might like to write your installation
instructions with a <code>-u</code> flag, e.g. the way <a href="https://github.com/golang/lint#installation">golint</a> does.</p>

<pre><code>$ go get -u github.com/golang/lint/golint
</code></pre>

<h3 id="go-get-d">$ go get -d</h3>

<p>If you just want to clone a repo to your GOPATH and skip the building
and installation phase, use <code>-d</code>. It downloads the package and stops
before trying to build or install it.</p>

<p>I often use it as a replacement for git clone for repos with vanity URLs,
because it clones the repo to its proper GOPATH.
For example,</p>

<pre><code>$ go get -d golang.org/x/oauth2/...
</code></pre>

<p>will clone the package to $GOPATH/src/golang.org/x/ouath2. Given golang.org/x/oauth2 is a
vanity URL, go-getting the repo is useful rather than trying to figure out
where the actual repo is (go.googlesource.com/oauth2).</p>

<h3 id="go-get-t">$ go get -t</h3>

<p>If your package has additional dependencies for tests, <code>-t</code> will allow you to
download them during go-get.
If you don&rsquo;t pass <code>-t</code>, go get will only download the dependencies for your non-test code.</p>

<h3 id="go-list-f">$ go list -f</h3>

<p>Allows you to list Go packages with a custom format. It is highly useful
for writing bash scripts.</p>

<p>The following command will print the dependencies of the runtime package:</p>

<pre><code>go list -f '{{.Deps}}' runtime
[runtime/internal/atomic runtime/internal/sys unsafe]
</code></pre>

<p>More formatting ideas can be found at
<a href="http://dave.cheney.net/2014/09/14/go-list-your-swiss-army-knife">Dave Cheney&rsquo;s article</a> on <code>go list</code>.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/examples-coverage/">
        Examples coverage
      </a>
    </h1>

    <span class="post-date">Thu, Sep 8, 2016</span>

    <p>Go programming language provides many unique good features to <a href="https://blog.golang.org/examples">
write and maintain examples</a> for your packages backed by the testing tools.</p>

<p>As an addition to the test coverage and test coverage report, <code>go test</code>
also can provide coverage for testable examples.</p>

<p>Use the following commands in your package to use the
<code>-run</code> flag to only the match the example tests and view the results
in your browser.</p>

<pre><code>$ go test -v -run=Example -coverprofile=c.out &amp;&amp; go tool cover -html=c.out
</code></pre>

<p>Please note that the coverage is reported for Examples with an Output block.
Examples without an &ldquo;Output&rdquo; block will not be tested and reported.</p>

<p>Here is what the <a href="/att/example-coverage.html">coverage</a> looks like
for the strings package from the stdlib.</p>

<p>High example coverage is probably not a neccesary signal
and not all lines are supposed to be documented with an example
but it might give you an idea whether you are missing out a significant
non-obvious case that needs to be documented
more comphensively.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/parallelize-test-tables/">
        Parallelize your table-driven tests
      </a>
    </h1>

    <span class="post-date">Tue, Sep 6, 2016</span>

    <p>With Go 1.7, testing package supports sub-tests that allows you to run
multiple smaller tests from a test case. Each sub test is reported
independently in the <code>go test</code> output. More information about these
recent additions can be found at <a href="https://speakerdeck.com/mpvl/advanced-testing-concepts-for-go-1-dot-7">Marcel van Lohuizen&rsquo;s recent talk</a>
from GolangUK 2016.</p>

<p>These additions to Go 1.7 enabled reporting and other testing.T
functionality for subtests. One of the biggest contributions of the
recent changes is to be able to use these features for table-driven tests.</p>

<p>The other important feature it enables is to be able to parallize the
subtests (where makes sense) by using (*testing.T).Parallize().</p>

<pre><code class="language-go">func TestFoo(t *testing.T) {
	tc := []struct {
		dur time.Duration
	}{
		{time.Second},
		{2 * time.Second},
		{3 * time.Second},
		{4 * time.Second},
	}
	for _, tt := range tc {
		tt := tt
		t.Run(&quot;&quot;, func(st *testing.T) {
			st.Parallel()
			time.Sleep(tt.dur)
		})
	}
}
</code></pre>

<p>The test suite above will run roughly in 4 seconds rather than 10 seconds.
TestFoo#01, TestFoo#02, TestFoo#03 and TestFoo#04 will begin at the same
time, will wait for <code>tt.dur</code> and be completed.</p>

<pre><code>$ go test -v
=== RUN   TestFoo
=== RUN   TestFoo/#00
=== RUN   TestFoo/#01
=== RUN   TestFoo/#02
=== RUN   TestFoo/#03
--- PASS: TestFoo (0.00s)
    --- PASS: TestFoo/#00 (1.00s)
    --- PASS: TestFoo/#01 (2.00s)
    --- PASS: TestFoo/#02 (3.00s)
    --- PASS: TestFoo/#03 (4.00s)
PASS
ok  	hello/subtests	4.020s
</code></pre>

<p>If you have table driven that are free from races and are majorly blocked
by anything other than your CPU, consider parallelizing them with the new sub tests.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/instruments/">
        Using Instruments to profile Go programs
      </a>
    </h1>

    <span class="post-date">Fri, Sep 2, 2016</span>

    <p>Apple has a suite of instrumentation and tracing tools for performance
analysis avaiable as a part of their Xcode tooling set. In this article,
we will use <a href="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/">Instruments</a>
to record and analyze the CPU profile of a Go program.</p>

<p>Instruments also provide a large set of macOS-specific tracing and profiling
if you have performance issues specifically on darwin.</p>

<p>Some of these specific profiles are:</p>

<ul>
<li>System trace: Collects comprehensive information about system calls,
scheduling, user-kernel space transitions. (Available only on OSX.)</li>
<li>System usage: Gives very detailed output about I/O system activity.
(Available only on iOS.)</li>
<li>File Activity: Monitors file and directory activity such as open/close,
permission modifications, creation, copying and moving.</li>
</ul>

<p>Instruments provide a rich and very easy to use UI to display profiles.
I highly recommend it as an addition to existing profiler UIs and vizualizers.</p>

<p>Now, let&rsquo;s profile a Go program.</p>

<p>Launch the Instruments app and select &ldquo;Time Profiler&rdquo;.</p>

<p>Create a target with your Go binary and arguments and env variables
you want to start the binary with. In this tutorial, I will use the
following program.</p>

<pre><code>go get -u github.com/rakyll/hey
</code></pre>

<p>We will use <code>hey</code> to make 10000 requests with 200 goroutines
to the target provided in the arguments.</p>

<p>The target I have for <code>hey</code> looks like what&rsquo;s below.</p>

<p><img src="/img/instruments-target.png" alt="Instruments target" /></p>

<p>Once you have a target, you can click on the record button to start
recording samples. Once enough samples are collected, stop or it will
eventually stop when the program finishes.</p>

<p><img src="/img/instruments-results.png" alt="Instruments results" /></p>

<p>You can filter by symbol name, user vs kernel callstacks, time span,
physical or logical CPU and more. You can also double click any of the symbols listed
to jump to the source code.</p>

<p>Please note that Go programs cannot work with every profile available
on Instruments. But there are a few profiles that absolutely can improve
your profiling experience. With stack frame pointers enabled by default in Go 1.7,
it became easier for tools like Instruments to capture backtraces more efficiently.</p>

<p>Happy profiling!</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/grpc-streaming/">
        Bidirectional gRPC streaming for Go
      </a>
    </h1>

    <span class="post-date">Tue, Aug 30, 2016</span>

    <p><em>Disclaimer: This article is not about a core Go package or tool but <a href="http://www.grpc.io/">gRPC</a>.</em></p>

<p>gRPC provides support for implementing streaming endpoints as well as
streaming support in their clients. Bidirectional streaming is useful
if you want both server and client to be able to communicate
to the other side independently in a full duplex fashion.</p>

<p>In this article, I will dig into how to use the streaming gRPC
Go client to talk to a streaming API endpoint.</p>

<p>I am not expecting the readers to implement a server, hence I will use an
existing service.
Google has recently realeased the <a href="https://cloud.google.com/speech/">Cloud Speech API</a>
which allows its users
to caption their audio input. Speech API also supports a bidirectional
streaming endpoint where you can sent audio data continously as you are
waiting on more responses from the server on another incoming channel.</p>

<p>Initialize a client:</p>

<pre><code class="language-go">stream, err := speech.NewSpeechClient(conn).StreamingRecognize(ctx)
if err != nil {
    log.Fatal(err)
}
</code></pre>

<p>We want to pipe the stdin to the API as we are printing the results.
Therefore, we will need two goroutines, one sending audio data to the
service and another retrieving the results.</p>

<p>The program will read from os.Stdin into an intermediate buffer and
will immediately push the buffer to the service.</p>

<pre><code class="language-go">go func() {
    // pipe stdin to the API
    buf := make([]byte, 1024)
    for {
        n, err := os.Stdin.Read(buf)
        if err == io.EOF {
            return // nothing else to pipe, kill this goroutine
        }
        if err != nil {
            // TODO: handle the error
            continue 
        }
        if err = stream.Send(&amp;speech.StreamingRecognizeRequest{
            StreamingRequest: &amp;speech.StreamingRecognizeRequest_AudioContent{
                AudioContent: buf[:n],
            },
        }); err != nil {
            // TODO: handle the error
        }
    }
}()
</code></pre>

<p>At the same time, the program will start reading the responses in the
main goroutine and print the captions as service pushes them:</p>

<pre><code class="language-go">for {
    resp, err := stream.Recv()
    if err == io.EOF {
        break
    }
    if err != nil {
        // TODO: handle the error
        continue
    }
    if resp.Error != nil {
        // TODO: handle the error
        continue
    }
    for _, result := range resp.Results {
        fmt.Printf(&quot;result: %+v\n&quot;, result)
    }
}
</code></pre>

<p>The full reference is living in a <a href="https://gist.github.com/rakyll/e7082fdcbdb18ee32997aa602ca164d6">gist</a>
where you can learn more about the initializing of the gRPC connection and more.</p>

<p>Please note that the same pattern of sending and receiving can be applied to
work with any gRPC bidirectional streaming client.</p>

  </div>
  
  
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/eg/">
        Apply transformations to Go code with eg
      </a>
    </h1>

    <span class="post-date">Sat, Aug 27, 2016</span>

    <p>If you are willing to make large scale refactoring in your
Go programs, automating the refactoring tasks is more desirable than
manual editing. <code>eg</code> is a program that allows you to perform transformations
based on template Go files.</p>

<p>To install the tool, run the following:</p>

<pre><code>$ go get golang.org/x/tools/cmd/eg
</code></pre>

<p><code>eg</code> requires a template file to look for which transformation it should
apply to your source code. What&rsquo;s nice is that the template file is a Go file
with little annotations.</p>

<p>Consider the following Go program:</p>

<pre><code class="language-go">$ cat $GOPATH/src/hello/hello.go
package hello

import &quot;time&quot;

// ExtendWith50000ns adds 50000ns to t.
func ExtendWith50000ns(t time.Time) time.Time {
	return t.Add(time.Duration(50000))
}
</code></pre>

<p>Assume you want to eliminate the unnecessary time.Duration casting at ExtendWith50000ns
and as a good practice, you would also like to add a unit to the duration rather than
just passing 50000.</p>

<p><code>eg</code> requires a template file where you define before and afters that represents the
transformation.</p>

<pre><code class="language-go">$ cat T.template
package template

import (
    &quot;time&quot;
)

func before(t time.Time, d time.Duration) time.Time {
    // if already time.Duration, do not cast.
    return t.Add(time.Duration(d))
}

func after(t time.Time, d time.Duration) time.Time  {
    return t.Add(d * time.Nanosecond)
}
</code></pre>

<p>And run the <code>eg</code> command on your hello package to apply it at every occurrence of this pattern.</p>

<pre><code>$ eg -w -t T.template hello
=== /Users/jbd/src/hello/hello.go (1 matches)
</code></pre>

<p>Voila!</p>

<p>The file now contains a duration that is not casted unnecessarily and it has a unit.</p>

<pre><code class="language-go">$ cat $GOPATH/src/hello/hello.go
package hello

import &quot;time&quot;

// ExtendWith50000ns adds 50000ns to t.
func ExtendWith50000ns(t time.Time) time.Time {
	return t.Add(50000 * time.Nanosecond)
}
</code></pre>

<p>Note: There are many <a href="https://github.com/golang/tools/tree/master/refactor/eg/testdata">.template files</a>
underneath the package for testing purposes but they can also be used as a
reference how to write other transformation templates.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/swift/">
        Calling Go from Swift
      </a>
    </h1>

    <span class="post-date">Sat, Oct 3, 2015</span>

    <p><em>Note: Swift bindings are highly experimental and subject to change.
This work must currently be classified as preliminary work and we will
be improving APIs in the long term.</em></p>

<p>As a part of the Go Mobile, we have announced tools and packages that
make language bindings from Java to Go and Objective-C to Go available.
A relatively new and less documented aspect of the bindings is the
availability of the Swift to Go calls. This tutorial will explain you
how to make your initial Swift to Go function invocation.</p>

<p>Grab the gomobile command and initialize it.</p>

<pre><code>$ go get golang.org/x/mobile/cmd/gomobile
$ gomobile init
</code></pre>

<p>In this tutorial, we will use an example Go package from the mobile repo
called hello to generate bindings for. The hello package exports a function
called Greetings and we will invoke this particular function from a
Swift-based iOS app. Go get the example hello package and run <code>gomobile bind</code>
to generate a framework bundle.</p>

<pre><code>$ go get golang.org/x/mobile/example/bind/hello/...
$ gomobile bind -target=ios golang.org/x/mobile/example/bind/hello
</code></pre>

<p>The command above is going to generate a bundle called Hello.framework on the
current working directory which includes a multi-arch C library and a header file.</p>

<p>The next step is to launch Xcode and open your existing Swift-based iOS app project.
Drag and drop the Hello.framework to the project.
This step will also automatically make the framework library linked to the final app product.</p>

<p><img src="/img/swift-xcode.png" alt="Xcode drag and drop" /></p>

<p>Once the framework bundle is imported, you are good to import the
Hello module and invoke GoHelloGreetings which is a proxy function for
hello.Greetings.</p>

<pre><code>import UIKit
import Hello
class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        println(Hello.GoHelloGreetings(&quot;gopher&quot;))
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }
}
</code></pre>

<p>Build and run it on your test device or the iOS simulator.
Enjoy making your first call to Go from Swift. Please note that this is
preliminary work and we would like to make changes to improve the APIs in the long term.
More information and tutorials about Go Mobile are available at
the <a href="https://golang.org/wiki/Mobile">wiki</a>.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://golang.rakyll.org/cross-compilation/">
        Go cross compilation
      </a>
    </h1>

    <span class="post-date">Tue, Sep 8, 2015</span>

    

<p>Note: This article extends <a href="http://dave.cheney.net/2015/03/03/cross-compilation-just-got-a-whole-lot-better-in-go-1-5">Dave Cheney’s Go 1.5 cross compilers</a> post.</p>

<p>Cross compilers got easier with Go 1.5.
You don’t have to bootstrap the standard library and toolchain as you
used to do prior to 1.5.</p>

<h3 id="if-cgo-is-not-required">If cgo is not required</h3>

<p>The go tool won’t require any bootstrapping if cgo is not required.
That allows you to target the following program to any GOOS/GOARCH without
requiring you to do any additional work. Invoke <code>go build</code>.</p>

<pre><code>$ cat main.go
package main
import &quot;fmt&quot;
func main() {
    fmt.Println(&quot;hello world&quot;)
}
</code></pre>

<p>In order to target android/arm, run the following command.</p>

<pre><code>$ GOOS=android GOARCH=arm GOARM=7 go build .
</code></pre>

<p>The produced binary is targeting ARMv7 processors that runs Android.
All possible GOOS and GOARCH values are listed on the <a href="https://golang.org/doc/install/source#environment">environment docs</a>.</p>

<h3 id="if-cgo-is-required">If cgo is required</h3>

<p>If you need to have cgo enabled, the go tool allows you to provide
custom C and C++ compilers via CC and CXX environment variables.</p>

<pre><code>$ CGO_ENABLED=1 CC=android-armeabi-gcc CXX=android-armeabi-g++ \
    GOOS=android GOARCH=arm GOARM=7 go build .
</code></pre>

<p>The toolchain will invoke android-armeabi-gcc and android-armeabi-g++
if it is required to compile any part of the package with a C or C++ compiler.
Consider the following program with a slightly different main function.
Rather than outputting &ldquo;hello world&rdquo; to the standard I/O,
it will use Android system libraries to write &ldquo;hello world&rdquo; to the system log.</p>

<pre><code>$ cat main.go
// +build android

package main

// #cgo LDFLAGS: -llog
//
// #include &lt;android/log.h&gt;
//
// void hello() {
//   __android_log_print(
//     ANDROID_LOG_INFO, &quot;MyProgram&quot;, &quot;hello world&quot;);
// }
import &quot;C&quot;
func main() {
    C.hello()
}
</code></pre>

<p>If you build the program with the command above and examine the build
with -x, you can observe that cgo is delegating the C compilation to
arm-linux-androideabi-gcc.</p>

<pre><code>$ CGO_ENABLED=1 \
CC=arm-linux-androideabi-gcc \
CXX=arm-linux-androideabi-g++ \
GOOS=android GOARCH=arm GOARM=7 go build -x .
...
CGO_LDFLAGS=”-g” “-O2” “-llog” /Users/jbd/go/pkg/tool/darwin_amd64/cgo -objdir $WORK/github.com/rakyll/hello/_obj/ -importpath github.com/rakyll/hello — -I $WORK/github.com/rakyll/hello/_obj/ main.go
arm-linux-androideabi-gcc -I . -fPIC -marm -pthread -fmessage-length=0 -print-libgcc-file-name
arm-linux-androideabi-gcc -I . -fPIC -marm -pthread -fmessage-length=0 -I $WORK/github.com/rakyll/hello/_obj/ -g -O2 -o $WORK/github.com/rakyll/hello/_obj/_cgo_main.o -c $WORK/github.com/rakyll/hello/_obj/_cgo_main.c
...
</code></pre>

<h3 id="pre-building-the-standard-library">Pre-building the standard library</h3>

<p>The go tool also provides a utility if you would like to pre-build the
standard library, targeting a specific GOOS and GOARCH.</p>

<pre><code>$ CGO_ENABLED=1 \
    CC=arm-linux-androideabi-gcc \
    CXX=arm-linux-androideabi-g++ \
    GOOS=android GOARCH=arm GOARM=7 go install std
</code></pre>

<p>The standard library targeting android/armv7 will be available at $GOROOT/pkg/android_arm.</p>

<pre><code>$ ls $GOROOT/pkg/android_arm
archive    fmt.a      math       runtime.a
bufio.a    go         math.a     sort.a
bytes.a    hash       mime       strconv.a
compress   hash.a     mime.a     strings.a
container  html       net        sync
crypto     html.a     net.a      sync.a
crypto.a   image      os         syscall.a
database   image.a    os.a       testing
debug      index      path       testing.a
encoding   internal   path.a     text
encoding.a io         reflect.a  time.a
errors.a   io.a       regexp     unicode
expvar.a   log        regexp.a   unicode.a
flag.a     log.a      runtime
</code></pre>

<p>If you prefer not to pre-build and install the standard library to the GOROOT,
required libraries will be built while building user packages.
But, the standard libraries builds are not preserved for future use at this
stage and they will be rebuilt each time you run <code>go build</code>.</p>

  </div>
  
  
  
  
</div>
</div>

  </body>
</html>
