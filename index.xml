<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go bits</title>
    <link>http://golang.rakyll.org/</link>
    <description>Recent content on go bits</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Sep 2016 11:27:27 -0400</lastBuildDate>
    <atom:link href="http://golang.rakyll.org/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using Instruments to profile Go programs</title>
      <link>http://golang.rakyll.org/instruments/</link>
      <pubDate>Fri, 02 Sep 2016 11:27:27 -0400</pubDate>
      
      <guid>http://golang.rakyll.org/instruments/</guid>
      <description>&lt;p&gt;Apple has a suite of instrumentation and tracing tools for performance
analysis avaiable as a part of their Xcode tooling set. In this article,
we will use &lt;a href=&#34;https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/&#34;&gt;Instruments&lt;/a&gt;
to record and analyze the CPU profile of a Go program.&lt;/p&gt;

&lt;p&gt;Instruments also provide a large set of macOS-specific tracing and profiling
if you have performance problems specifically on darwin.&lt;/p&gt;

&lt;p&gt;Some of these specific profiles are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;System trace: Collects comprehensive information about system calls,
scheduling, user-kernel space transitions.&lt;/li&gt;
&lt;li&gt;System usage: Gives very detailed output about I/O system activity.&lt;/li&gt;
&lt;li&gt;File Activity: Monitors file and directory activity such as open/close,
permission modifications, creation, copying and moving.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Instruments provide a rich and very easy to use UI to display profiles.
I highly recommend it as an addition to existing profile vizualizers that
works with Go programs as of today.&lt;/p&gt;

&lt;p&gt;Launch the Instruments app and select &amp;ldquo;Time Profiler&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Create a target with your Go binary and arguments and env variables
you want to start the binary with. In this tutorial, I will use the
following program.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -u github.com/rakyll/hey
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The target I have for &lt;code&gt;hey&lt;/code&gt; looks like what&amp;rsquo;s below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://golang.rakyll.org/img/instruments-target.png&#34; alt=&#34;Instruments target&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Once you have a target, you can click on the record button to start
recording samples. Once enough samples are collected, stop or it will
eventually stop when the program finishes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://golang.rakyll.org/img/instruments-results.png&#34; alt=&#34;Instruments results&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can filter by symbol name, user vs kernel callstacks, time span,
physical or logical CPU and more. You can also double click any of the symbols listed
to jump to the source code.&lt;/p&gt;

&lt;p&gt;Please note that Go programs cannot work with every profile available
on Instruments. But there are a few profiles that absolutely can improve
your profiling experience and meet your filtering requirements.&lt;/p&gt;

&lt;p&gt;Happy profiling!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bidirectional gRPC streaming for Go</title>
      <link>http://golang.rakyll.org/grpc-streaming/</link>
      <pubDate>Tue, 30 Aug 2016 11:27:27 -0400</pubDate>
      
      <guid>http://golang.rakyll.org/grpc-streaming/</guid>
      <description>&lt;p&gt;&lt;em&gt;Disclaimer: This article is not about a core Go package or tool but &lt;a href=&#34;http://www.grpc.io/&#34;&gt;gRPC&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;gRPC provides support for implementing streaming endpoints as well as
streaming support in their clients. Bidirectional streaming is useful
if you want both server and client to be able to communicate
to the other side independently in a full duplex fashion.&lt;/p&gt;

&lt;p&gt;In this article, I will dig into how to use the streaming gRPC
Go client to talk to a streaming API endpoint.&lt;/p&gt;

&lt;p&gt;I am not expecting the readers to implement a server, hence I will use an
existing service.
Google has recently realeased the &lt;a href=&#34;https://cloud.google.com/speech/&#34;&gt;Cloud Speech API&lt;/a&gt;
which allows its users
to caption their audio input. Speech API also supports a bidirectional
streaming endpoint where you can sent audio data continously as you are
waiting on more responses from the server on another incoming channel.&lt;/p&gt;

&lt;p&gt;Initialize a client:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;stream, err := speech.NewSpeechClient(conn).StreamingRecognize(ctx)
if err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to pipe the stdin to the API as we are printing the results.
Therefore, we will need two goroutines, one sending audio data to the
service and another retrieving the results.&lt;/p&gt;

&lt;p&gt;The program will read from os.Stdin into an intermediate buffer and
will immediately push the buffer to the service.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go func() {
    // pipe stdin to the API
    buf := make([]byte, 1024)
    for {
        n, err := os.Stdin.Read(buf)
        if err == io.EOF {
            return // nothing else to pipe, kill this goroutine
        }
        if err != nil {
            // TODO: handle the error
            continue 
        }
        if err = stream.Send(&amp;amp;speech.StreamingRecognizeRequest{
            StreamingRequest: &amp;amp;speech.StreamingRecognizeRequest_AudioContent{
                AudioContent: buf[:n],
            },
        }); err != nil {
            // TODO: handle the error
        }
    }
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the same time, the program will start reading the responses in the
main goroutine and print the captions as service pushes them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for {
    resp, err := stream.Recv()
    if err == io.EOF {
        break
    }
    if err != nil {
        // TODO: handle the error
        continue
    }
    if resp.Error != nil {
        // TODO: handle the error
        continue
    }
    for _, result := range resp.Results {
        fmt.Printf(&amp;quot;result: %+v\n&amp;quot;, result)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full reference is living in a &lt;a href=&#34;https://gist.github.com/rakyll/e7082fdcbdb18ee32997aa602ca164d6&#34;&gt;gist&lt;/a&gt;
where you can learn more about the initializing of the gRPC connection and more.&lt;/p&gt;

&lt;p&gt;Please note that the same pattern of sending and receiving can be applied to
work with any gRPC bidirectional streaming client.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>eg to apply transformations to Go code</title>
      <link>http://golang.rakyll.org/eg/</link>
      <pubDate>Sat, 27 Aug 2016 11:27:27 -0400</pubDate>
      
      <guid>http://golang.rakyll.org/eg/</guid>
      <description>&lt;p&gt;If you are willing to make large scale refactoring in your
Go programs, automating the refactoring tasks is more desirable than
manual editing. &lt;code&gt;eg&lt;/code&gt; is a program that allows you to perform transformations
based on template Go files.&lt;/p&gt;

&lt;p&gt;To install the tool, run the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get golang.org/x/tools/cmd/eg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;eg&lt;/code&gt; requires a template file to look for which transformation it should
apply to your source code. What&amp;rsquo;s nice is that the template file is a Go file
with little annotations.&lt;/p&gt;

&lt;p&gt;Consider the following Go program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cat $GOPATH/src/hello/hello.go
package hello

import &amp;quot;time&amp;quot;

// ExtendWith50000ns adds 50000ns to t.
func ExtendWith50000ns(t time.Time) time.Time {
	return t.Add(time.Duration(50000))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assume you want to eliminate the unnecessary time.Duration casting at ExtendWith50000ns
and as a good practice, you would also like to add a unit to the duration rather than
just passing 50000.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eg&lt;/code&gt; requires a template file where you define before and afters that represents the
transformation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cat T.template
package template

import (
    &amp;quot;time&amp;quot;
)

func before(t time.Time, d time.Duration) time.Time {
    // if already time.Duration, do not cast.
    return t.Add(time.Duration(d))
}

func after(t time.Time, d time.Duration) time.Time  {
    return t.Add(d * time.Nanosecond)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run the &lt;code&gt;eg&lt;/code&gt; command on your hello package to apply it at every occurrence of this pattern.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eg -w -t T.template hello
=== /Users/jbd/src/hello/hello.go (1 matches)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voila!&lt;/p&gt;

&lt;p&gt;The file now contains a duration that is not casted unnecessarily and it has a unit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cat $GOPATH/src/hello/hello.go
package hello

import &amp;quot;time&amp;quot;

// ExtendWith50000ns adds 50000ns to t.
func ExtendWith50000ns(t time.Time) time.Time {
	return t.Add(50000 * time.Nanosecond)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: There are many &lt;a href=&#34;https://github.com/golang/tools/tree/master/refactor/eg/testdata&#34;&gt;.template files&lt;/a&gt;
underneath the package for testing purposes but they can also be used as a
reference how to write other transformation templates.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>