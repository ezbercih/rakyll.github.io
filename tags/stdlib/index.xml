<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stdlib on go bits</title>
    <link>http://golang.rakyll.org/tags/stdlib/index.xml</link>
    <description>Recent content in Stdlib on go bits</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://golang.rakyll.org/tags/stdlib/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using contexts to avoid leaking goroutines</title>
      <link>http://golang.rakyll.org/leakingctx/</link>
      <pubDate>Tue, 25 Oct 2016 11:27:27 -0400</pubDate>
      
      <guid>http://golang.rakyll.org/leakingctx/</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;https://godoc.org/pkg/context&#34;&gt;context&lt;/a&gt; package makes it possible
to manage a chain of calls within the same call path by signaling context&amp;rsquo;s
Done channel.&lt;/p&gt;

&lt;p&gt;In this article, we will examine how to use the context package to
avoid leaking goroutines.&lt;/p&gt;

&lt;p&gt;Assume, you have a function that starts a goroutine internally. Once this
function is called, the caller may not be able to terminate the goroutine
started by the function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gen is a broken generator that will leak a goroutine.
func gen() &amp;lt;-chan int {
	ch := make(chan int)
	go func() {
		var n int
		for {
			ch &amp;lt;- n
			n++
		}
	}()
	return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The generator above starts a goroutine with an infinite loop,
but the caller consumes the values until n is equal to 5.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// The call site of gen doesn&#39;t have a 
for n := range gen() {
    fmt.Println(n)
    if n == 5 {
        break
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the caller is done with the generator (when it breaks the loop),
the goroutine will run forever executing the infinite loop. Our code
will leak a goroutine.&lt;/p&gt;

&lt;p&gt;We can avoid the problem by signaling the internal goroutine with a
stop channel but there is a better solution: cancellable contexts.
The generator can select on a context&amp;rsquo;s Done channel and once the context is
done, the internal goroutine can be cancelled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gen is a generator that can be cancellable by cancelling the ctx.
func gen(ctx context.Context) &amp;lt;-chan int {
	ch := make(chan int)
	go func() {
		var n int
		for {
			select {
			case &amp;lt;-ctx.Done():
				return // avoid leaking of this goroutine when ctx is done.
			case ch &amp;lt;- n:
				n++
			}
		}
	}()
	return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, the caller can signal the generator when it is done consuming.
Once cancel function is called, the internal goroutine will be returned.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ctx, cancel := context.WithCancel(context.Background())
defer cancel() // make sure all paths cancel the context to avoid context leak

for n := range gen(ctx) {
    fmt.Println(n)
    if n == 5 {
        cancel()
        break
    }
}

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full program is available as a &lt;a href=&#34;https://gist.github.com/rakyll/1aa860377dab8fd445431bbb3204f600&#34;&gt;gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>