<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Readability on Go, the unwritten parts</title>
    <link>https://rakyll.org/tags/readability/index.xml</link>
    <description>Recent content in Readability on Go, the unwritten parts</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://rakyll.org/tags/readability/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Naming tests to self-document</title>
      <link>https://rakyll.org/naming-tests-to-doc/</link>
      <pubDate>Fri, 03 Feb 2017 11:27:27 -0400</pubDate>
      
      <guid>https://rakyll.org/naming-tests-to-doc/</guid>
      <description>&lt;p&gt;Go doesn&amp;rsquo;t specifically enforce you how you choose your test names.
Tests are a significant contributors for the maintainability
of your code. Tests not just providing correctness checking
but also are useful in self documenting your code and its usage.
On top of that, tests are the single best source to read about
responsbilities of a type, function, etc.
This is where naming tests better can help the internal documentation
and therefore the maintainability of your code.&lt;/p&gt;

&lt;p&gt;Emphasize the role of what you are testing rather than naming
after the inputs and outputs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-wrong&#34;&gt;func TestTitleIllegalChar(t *testing.T) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead, explain that the doc needs to be able to escape illegal
characters on edit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func TestTitleEscape(t *testing.T) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this rename, we also self-document how the illegal characters
on the title will be handled.&lt;/p&gt;

&lt;p&gt;We sometimes pick very inclusive test names and write big table-driven
tests. If you are running table-driven tests, you can convert them to
&lt;a href=&#34;https://blog.golang.org/subtests&#34;&gt;subtests&lt;/a&gt; and name the individual cases.
Then &lt;code&gt;go test -v&lt;/code&gt; can pick those name and its output will act as a spec of
your type, function, etc.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Style guideline for Go packages</title>
      <link>https://rakyll.org/style-packages/</link>
      <pubDate>Sat, 14 Jan 2017 11:27:27 -0400</pubDate>
      
      <guid>https://rakyll.org/style-packages/</guid>
      <description>

&lt;p&gt;Go is about naming and organization as much as everything else in the language.
Well-organized Go code is easy to discover,
use and read. Well-organized code is as critical as well designed APIs. The location, name,
and the structure of your packages are the first elements your users see and interact with.&lt;/p&gt;

&lt;p&gt;This document&amp;rsquo;s goal is to guide you with common good practices not to set rules.
You will always need to use your own judgement to pick the most elegant solution
for your specific case.&lt;/p&gt;

&lt;h2 id=&#34;packages&#34;&gt;Packages&lt;/h2&gt;

&lt;p&gt;All Go code is organized into packages. A package in Go is simply a directory/folder with one or more
&lt;code&gt;.go&lt;/code&gt; files inside of it. Go packages provide isolation and organization of code similar to
how directories/folders organize files on a computer.&lt;/p&gt;

&lt;p&gt;All Go code lives in a package and a package is the entry point to access Go code. Understanding
and establishing good practices around packages is important to write effective Go code.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;package-organization&#34;&gt;Package Organization&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s begin with suggestions how you should organize Go code and explain conventions about
locating Go packages.&lt;/p&gt;

&lt;h3 id=&#34;use-multiple-files&#34;&gt;Use multiple files&lt;/h3&gt;

&lt;p&gt;A package is a directory with one or more Go files.
Feel free to separate your code into as many files as logically
make sense for optimal readability.&lt;/p&gt;

&lt;p&gt;For example, an HTTP package might have been separated into different files
according to the HTTP aspect the file handles.
In the following example, an HTTP package is broken down into a few files:
header types and code, cookie types and code, the actual HTTP implementation, and
documentation of the package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- doc.go       // package documentation
- headers.go   // HTTP headers types and code
- cookies.go   // HTTP cookies types and code
- http.go      // HTTP client implementation, request and response types, etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;keep-types-close&#34;&gt;Keep types close&lt;/h3&gt;

&lt;p&gt;As a rule of thumb, keep types closer to where they are used. This makes it easy for
any maintainer (not just the original author) to find a type.
A good place for a Header struct type might be in &lt;code&gt;headers.go&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat headers.go
package http

// Header represents an HTTP header.
type Header struct {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though, the Go language doesn&amp;rsquo;t restrict where you define types,
it is often a good practice to keep the core types grouped at the top of a file.&lt;/p&gt;

&lt;h3 id=&#34;organize-by-responsbility&#34;&gt;Organize by responsbility&lt;/h3&gt;

&lt;p&gt;A common practise from other languages is to organize types together in a package
called models or types. In Go, we organize code by their functional responsibilities.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-wrong&#34;&gt;package models // DON&#39;T DO IT!!!

// User represents a user in the system.
type User struct {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rather than creating a models package and declare all entity types there,
a User type should live in a service-layer package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package mngtservice

// User represents a user in the system.
type User struct {...}

func UsersByQuery(ctx context.Context, q *Query) ([]*User, *Iterator, error)

func UserIDByEmail(ctx context.Context, email string) (int64, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;optimize-for-godoc&#34;&gt;Optimize for godoc&lt;/h3&gt;

&lt;p&gt;It is a great exercise to use godoc in the early phases of your package&amp;rsquo;s API design to see
how your concepts will be rendered on doc. Sometimes, the visualization also has an impact
on the design. Godoc is the way your users will consume a package, so it is ok to tweak
things to make them more accessible. Run &lt;code&gt;godoc -http=&amp;lt;hostport&amp;gt;&lt;/code&gt; to start a godoc server locally.&lt;/p&gt;

&lt;h3 id=&#34;provide-examples-to-fill-the-gaps&#34;&gt;Provide examples to fill the gaps&lt;/h3&gt;

&lt;p&gt;In some cases, you may not be able to provide all related types from a single package. It might be noisy
to do so, or you might want to publish concrete implementations of a common interface from a separate
package, or those types could be owned by a third-party package.
Give examples to help the user to discover and understand how they are used together.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ godoc cloud.google.com/go/datastore
func NewClient(ctx context.Context, projectID string, opts ...option.ClientOption) (*Client, error)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NewClient works with option.ClientOptions but it is neither the datastore package
nor the option package that export all the option types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ godoc google.golang.org/extraoption
func WithCustomValue(v string) option.ClientOption
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your API requires many non-standard packages to be imported, it is often useful to add
a &lt;a href=&#34;https://blog.golang.org/examples&#34;&gt;Go example&lt;/a&gt; to give your users some working code.&lt;/p&gt;

&lt;p&gt;Examples are a good way to increase visibility of a less discoverable package.
For example, an example for datastore.NewClient might reference the extraoption package.&lt;/p&gt;

&lt;h3 id=&#34;don-t-export-from-main&#34;&gt;Don&amp;rsquo;t export from main&lt;/h3&gt;

&lt;p&gt;An identifier may be &lt;a href=&#34;https://golang.org/ref/spec#Exported_identifiers&#34;&gt;exported&lt;/a&gt;
to permit access to it from another package.&lt;/p&gt;

&lt;p&gt;Main packages are not importable, so exporting identifiers from main packages is unnecessary.
Don&amp;rsquo;t export identifiers from a main package if you are building the package to a binary.&lt;/p&gt;

&lt;p&gt;Exceptions to this rule might be the main packages built into a .so, or a .a or Go plugin.
In such cases, Go code might be used from other languages via
&lt;a href=&#34;https://golang.org/cmd/cgo/#hdr-C_references_to_Go&#34;&gt;cgo&amp;rsquo;s export functionality&lt;/a&gt;
and exporting identifiers are required.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;package-naming&#34;&gt;Package Naming&lt;/h2&gt;

&lt;p&gt;A package name and import path are both significant identifiers of your package
and represent everything your package contains. Naming your packages canonically
not just improves your code quality but also your users&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;lowercase-only&#34;&gt;Lowercase only&lt;/h3&gt;

&lt;p&gt;Package names should be lowercase. Don&amp;rsquo;t use snake_case or camelCase in package names.
The Go blog has a &lt;a href=&#34;https://blog.golang.org/package-names&#34;&gt;comprehensive guide&lt;/a&gt; about naming packages
with a good variety of examples.&lt;/p&gt;

&lt;h3 id=&#34;short-but-representative-names&#34;&gt;Short, but representative names&lt;/h3&gt;

&lt;p&gt;Package names should be short, but should be unique and representative.
Users of the package should be able to grasp its purpose from just the package&amp;rsquo;s name.&lt;/p&gt;

&lt;p&gt;Avoid overly broad package names like &amp;ldquo;common&amp;rdquo; and &amp;ldquo;util&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-wrong&#34;&gt;import &amp;quot;pkgs.org/common&amp;quot; // DON&#39;T!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Avoid duplicate names in cases where user may need to import the same package.&lt;/p&gt;

&lt;p&gt;If you cannot avoid a bad name, it is very likely that there is a problem
with your overall structure and code organization.&lt;/p&gt;

&lt;h3 id=&#34;clean-import-paths&#34;&gt;Clean import paths&lt;/h3&gt;

&lt;p&gt;Avoid exposing your custom repository structure to your users. Align
well with the GOPATH conventions. Avoid having src/, pkg/
sections in your import paths.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-wrong&#34;&gt;github.com/user/repo/src/httputil   // DON&#39;T DO IT, AVOID SRC!!

github.com/user/repo/gosrc/httputil // DON&#39;T DO IT, AVOID GOSRC!!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;no-plurals&#34;&gt;No plurals&lt;/h3&gt;

&lt;p&gt;In go, package names are not plural. This is surprising to programmers who came
from other languages and are retaining an old habit of pluralizing names.
Don&amp;rsquo;t name a package httputils, but httputil!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-wrong&#34;&gt;package httputils  // DON&#39;T DO IT, USE SINGULAR FORM!!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;renames-should-follow-the-same-rules&#34;&gt;Renames should follow the same rules&lt;/h3&gt;

&lt;p&gt;If you are importing more than one packages with the same name, you can locally
rename the package names. The renames should follow the same rules mentioned
on this article. There is no rule which package you should rename. If you are
renaming the standard package library, it is nice to add a go prefix to make the name
self document that it is &amp;ldquo;Go standard library&amp;rsquo;s&amp;rdquo; package, e.g. &lt;code&gt;gourl&lt;/code&gt;, &lt;code&gt;goioutil&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import (
    gourl &amp;quot;net/url&amp;quot;

    &amp;quot;myother.com/url&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enforce-vanity-urls&#34;&gt;Enforce vanity URLs&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go get&lt;/code&gt; supports getting packages by a URL that is different than the URL
of the package&amp;rsquo;s repo. These URLs are called vanity URLs and require you to
serve a page with specific meta tags the Go tools recognize.
You can serve a package with a custom domain and path using vanity URLs.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get cloud.google.com/go/datastore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;checks out the source code from &lt;code&gt;https://code.googlesource.com/gocloud&lt;/code&gt; behind
the scenes and puts it in your workspace under $GOPATH/src/cloud.google.com/go/datastore.&lt;/p&gt;

&lt;p&gt;Given code.googlesource.com/gocloud is already serving this package, would it
be possible to go get the package from that URL? The answer is no, if you enforce
the vanity URL.&lt;/p&gt;

&lt;p&gt;To do that, add an import statement to the package. The go tool will reject
any import of this package from any other path and will display a friendly
error to the user. If you don&amp;rsquo;t enforce your vanity URLs, there will be two
copies of your package that cannot work together due to the different namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package datastore // import &amp;quot;cloud.google.com/go/datastore&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;package-documentation&#34;&gt;Package Documentation&lt;/h2&gt;

&lt;p&gt;Always document the package. Package documentation is a top-level comment
immediately preceding the package clause. For non-main packages, godoc always starts with
&amp;ldquo;Package {pkgname}&amp;rdquo; and follows with a description. For main packages, documentation
should explain the binary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Package ioutil implements some I/O utility functions.
package ioutil

// Command gops lists all the processes running on your system.
package main

// Sample helloworld demonstrates how to use x.
package main
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;use-doc-go&#34;&gt;Use doc.go&lt;/h3&gt;

&lt;p&gt;Sometimes, package docs can get very lengthy, especially when they provide details
of usage and guidelines.
Move the package godoc to a &lt;code&gt;doc.go&lt;/code&gt; file.
(See an example of a &lt;a href=&#34;https://github.com/GoogleCloudPlatform/google-cloud-go/blob/master/datastore/doc.go&#34;&gt;doc.go&lt;/a&gt;.)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Interface pollution in Go</title>
      <link>https://rakyll.org/interface-pollution/</link>
      <pubDate>Sat, 18 Oct 2014 11:27:27 -0400</pubDate>
      
      <guid>https://rakyll.org/interface-pollution/</guid>
      <description>&lt;p&gt;If there was a single powerful language feature in Go, it’d be the interfaces.
The internals of Go contain strong combinations of useful ideas from various type
systems and inevitably they ring the curiosity bells. I recently surveyed Github
for Go interface declarations, and the results indicated that Go users pollute
the environment with interfaces no one needs or will use.&lt;/p&gt;

&lt;p&gt;Don’t export any interfaces until you have to.&lt;/p&gt;

&lt;p&gt;Interfaces are great, but interface pollution is not so. You’re likely to come to
Go from a language (if not from a dynamic language) that generates a static dispatch
table during compilation, the compiler require you to explicitly tell the interfaces
a type wants to implement. That’s how the complier can generate a vtable with pointers
to all available virtual functions. If your background is in C++ or Java, you’re likely
to have some baggage around initiating your codebase with abstract types and work on the
concrete implementation as a follow-up exercise. This is not how you do it in Go.
Introduce concrete types and don’t export any interfaces unless you have to encourage
external packages to implement one. io package is a good starting point to study some
of the the best practices. It exports interfaces because it also needs to export
generic-use functions like Copy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Copy(dst Writer, src Reader) (written int64, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Should your package export generic functionality? If the answer is a “maybe”,
you’re likely to be polluting your package with an interface declaration.
Justify the need of multiple implementations, likeliness of them to interact
back with your package and act accordingly.&lt;/p&gt;

&lt;p&gt;Go doesn’t have a traditional dispatch table, and can rely on the interface values
during a method dispatch. It’s literally more of a freestyle dispatcher mechanism
that requires some work during interface value assignment — it generates a tiny lookup
hash-table for the concrete type it’s pointing to. The assignment is not insanely
expensive, so it’s a fair exchange for a more pleasant type system.
Ian Lance Taylor has &lt;a href=&#34;http://www.airs.com/blog/archives/277&#34;&gt;a great blog post about the internals&lt;/a&gt;
if you’re looking for further reading.&lt;/p&gt;

&lt;p&gt;If a user requires some level of “inversion of control”, an on-the-fly interface
definition in their own scope would just work. This possibility minimizes the
presumptions you have to make about the way your package is being consumed and
the initial abstractions you have to work on.&lt;/p&gt;

&lt;p&gt;It also applies to the testability concerns, you don’t have to provide interfaces
to help the user to write their own stubs. Earlier today, I got a request to export
an interface from the pubsub package to make it more mockable. Rather than doing so,
the preferable way is to tell your user to introduce an interface that focuses on the
calls they want to write a stub for. Point to the actual implementation via an interface value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type acknowledger interface {
    Ack(sub string, id ...string) error
}

type mockClient struct{}

func (c *mockClient) Ack(sub string, id ...string) error {
    return nil
}

var acker acknowledger = pubsub.New(...)

acker = &amp;amp;mockClient{} // in the test package
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Noteworthy that, in Go, the standard library defines tiny interfaces you happen to
implement without effort and is doing a good job at encouraging the developers to write
compatible code with the rest of the standard library — and the other third party packages.
Adopt what’s available in the standard library where possible and document accordingly.&lt;/p&gt;

&lt;p&gt;Go fascinates me each time I deeply reevaluate my experience with the interfaces.
Given the chance of minimal fragmentation in interfaces, this is how a programming
language make software, that isn’t designed to work together, work well together.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>